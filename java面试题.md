# java基础
## 最有效率的方法计算2*8

2<<3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）

## short s1 = 1; s1 = s1+1；short s1 = 1; s1+=1 这两条有错吗

- 对于short s1 = 1; s1 = s1 + 1；由于1是int类型，因此s1+1运算结果也是int型，需要强制转换类型才能赋值给short型
- 而short s1 = 1; s1+= 1;可以正常编译，因为s1+=1其中有隐含的强制类型转换。

## &和&&的区别（同|和||的区别）

- &运算符有两种用法：(1)按位与；(2)逻辑与
- &&运算符是短路与运算。逻辑与和按位与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true整个表达式的值才是true。&&之所以称为短路运算，是因为如果&&左边的表达式的值是false，右边的表达式会直接短路，不会进行运算。

## 面向对象的三大特征是什么

- __封装__：把一个对象的属性私有化，同时提供一些可以被外界访问的属性和方法
- __继承__：使用已存在的类的定义作为基础建立新的类的技术，新类的定义可以增加新的数据或者新的功能，也可以用父类的功能，但不能选择性的继承父类。通过使用继承我们能够非常方便的复用以前的代码。
  - 子类拥有父类非private的属性和方法
  - 子类用于自己的属性和方法，即子类可以对父类进行拓展
  - 子类可以用自己方式实现父类的方法，即重写
- __多态__：父类或接口定义的引用变量可以指向子类或者具体实现类的实例对象。提高了程序的拓展性。在Java中有两种形式可以实现多态：继承和接口

## 抽象类和接口的区别

1. 语法区别
  1. 抽象类可以有构造方法，接口不能有构造方法
  2. 抽象类中可以有普通成员变量，接口中没有普通成员变量
  3. 抽象类中可以有非抽象的方法，接口中的所有方法必须是抽象方法
  4. 抽象类中的方法可以使pulic, protected类型，接口中的方法只能是public类型的，且默认为public abstract类型
  5. 抽象类中可以有静态方法，接口中不能有静态方法
  6. 抽象类中的静态变量访问类型可以使任意的，但接口中的静态变量只能是public static final类型
  7. 一个类可以实现多个接口，但是一个类只能继承一个抽象类
2. 应用区别
    接口更多是在系统架构方面发挥作用，主要用于定义模块之间的通信契约；而抽象类在代码方面发挥作用，可以使用代码块的重用
## 重写与重载的区别

- 方法的重载和重写都是实现多态的方式，区别在于重载实现的是编译时的多态性，而重写实现的是运行时的多态性
- 重载：发生在同一个类中，方法名相同，但是参数列表不同（参数类型、个数、顺序 不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分
- 重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类；如果父类方法修饰符为private，则子类中就不能重写

## java中接口可不可以继承一般类，为什么
### 答案
不可以
### 原因
接口中只能出现三种成员：
1. 公共的静态常量(public static final)
2. 公共的抽象方法(public abstract)
3. 静态内部类(static class)
而一个类中，就算什么都不写，也必须带一个构造方法，在extends时就会被子类继承，如果是接口也会继承这个构造方法，很明显构造方法不在上面三项之列
而如果类中有一般的方法和成员变量，也会被子类全部继承，这些更不能出现在接口中了，所以接口是绝对不可能继承一个普通类的
## 基本数据类型的默认值什么？基本数据类型所占的字节长度
1. 默认值
	1. byte、short、int、long的默认值为0
	2. float、double默认值为0.0
	3. char默认值为空
	4. boolean默认值为false
2. 所占字节
	1. byte 1个字节
	2. short 2个字节
	3. char 2个字节
	4. int 4个字节
	5. long 8个字节
	6. float 4个字节
	7. double 8个字节
	8. boolean
		1. boolean类型 被编译为int类型，在JVM里占用字节和int完全一样，int是4字节，所以boolean也是4字节
		2. boolean数组 在Oracle的JVM中，编码为byte数组，每个boolean元素占用8位=1字节
		3. boolean数组在非Oracle JVM中，占用字节数也许不是1字节
		4. 文章来源：https://blog.csdn.net/amoscn/article/details/97377833
## String属于哪个类，常用的方法有哪些
1. String属于java.lang.string
2. 常用的方法
	1. equals(Object obj): 比较字符串的内容是否相同，return boolean
	2. substring(int beginIndex,int endIndex):返回一个新的字符串，从beginIndex(包含)开始,截取到endIndex(不包含)的一个子字符串，当endIndex不传的时候，截取到最后，return String
	3. indexOf(String str,int formIndex): 返回指定子字符串在第一次出现处的下标，从指定索引开始，当formIndex为空时，返回整个字符串中第一次出现的下标，return int
	4. contains(CharSequence s): 当且仅当此字符串包含指定的char值序列时，返回true，return boolean
	5. startsWith(String buffix)/endswith(String buffix): 测试此字符串是否以指定的前/后缀，开始/结束，return boolean
	6. length()：返回字符串的长度：return value.length
	7. replace(char oldChar, char newChar): 返回一个新的字符串，它是通过用newChar替换词字符串中出现的所有oldChar得到，return String
	8. trim(): 返回字符串的副本，忽略字符串开始和结束的空白，return String

## equals方法和== 的用法和区别
equals方法是java.lang.object类的方法
1. == 比较两个变量本身的值，即两个对象在内存中的首地址
	 java中，对象的首地址是它在内存中存放的起始地址，它后来的地址是用来存放它所包含的各个属性的地址，所以内存中会用多个内存块来存放对象的各个参数，而通过这个首地址就可以找到该对象，进而可以找到该对象的各个属性
2. equals()比较的是字符串中所包含的内容的值是否相同(String类中重新定义了equals方法，比较的是值，而不是地址)
3. StringBuffer类中没有重新定义equals这个方法，所以这个方法来自Object类(Object类中的equals方法是用来比较地址的)
4. 如果是基本类型比较，那么只能用== 来比较，不能用equals
## String、StringBuffer、StringBuilder
1. String类
  1. String是由final修饰，因此它是线程安全的。
  2. String的值是不可变的，这就导致每次对String的操作都会生成一个新的String对象，不仅效率低下，而且浪费内存空间，所以使用场景为少量字符串操作的时候

2. StringBuffer类
  1. StringBuffer是考虑多线程的情况，所以它是线程安全的
  2. StringBuffer相较于StringBuilder效率相对低一些，但是远比String要高得多，所以适用于多线程环境下的大量字符串操作。

3. StringBuilder类
  1. 没有考虑线程安全问题，所以它是非线程安全
  2. StringBuilder执行效率是最高的，但是因为线程不安全，所以适用于单线程环境下的大量字符串操作


## final的作用

1. final修饰的成员变量，必须在声明的时候进行赋值，并且声明后，值不可被修改
2. final修饰的方法，不能被子类重写
3. final类中的方法默认是final的，且final类不能被继承
4. private类型的方法默认是final的

## String str = "i" 和 String str = new String("i")一样吗

不一样，区别如下：

String str = "i" 会将其分配到常量池中，常量池中不会存在重复的元素，如果常量池中存在i，则直接将i的内存地址赋值给变量，如果没有的话就创建一个然后再赋值给变量

String str = new String("i") 会将对象分配到堆中，即使内存中存在，还是会重新创建一个新的对象

## java中IO流分为几种

1. 按流划分，可以分为输入流和输出流
2. 按单位划分，可以分为字节流和字符流
   1. 字节流：inputStream,outputStream
   2. 字符流：reader,writer
## 冒泡排序
```java
public static void sort(int[] a){
	//外层循环，需要进行比较的轮次，一共进行数组a的数量次数
	for(int i = 0; i < a.length-1; i++){
		//内层循环，每一轮中两两比较
		for(int j = 0; j < a.length-i-1; j++){
			if(a[j] > a[j+1]){
				int temp = a[j];
				a[j] = a[j+1];
				a[j+1] = temp;
			}
		}
	}
}
```
# Java 反射

## 什么是反射机制

- Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java的反射机制。
- 静态编译和动态编译
  - 静态编译：在编译时确定类型，绑定对象
  - 动态编译：运行时确定类型，绑定对象

## 反射机制优缺点

- 优点：运行期类型的判断，动态加载类，提高代码灵活度
- 缺点：性能瓶颈：反射相当于一系列解释操作，通知JVM要做的事，性能会比直接的Java代码慢很多

## 反射机制的应用场景有哪些

- 反射是框架设计的灵魂
- 模块化的开发，通过反射调用对应的字节码；动态代理设计模式也采用了反射机制，还有Spring、Hibernate等框架也都大量使用了反射机制

## Java获取反射的三种方法

1. 通过new对象实现反射机制
2. 通过路径实现反射机制
3. 通过类名实现反射机制

实例代码：

```java
public class Student{
  private int id;
  String name;
  protected boolean sex;
  public float score;
}

public class Get{
  //获取反射机制的三种方式
  public static void main(String[] args) throws ClassNotFoundException{
    //1.通过建立对象
    Student stu = new Student();
    Class class1 = stu.getClass();
    System.out.println(class1.getName());
    //2.所在通过路径--相对路径
    Class class2 = Class.forName("fanshe.Student");
    System.out.println(class2.getName());
    //3.通过类名
    Class class3 = Student.class;
    System.out.println(class3.getName());
  }
}
```



# Java 集合

## HashMap和HashTable的区别

1. HashMap继承自AbstractMap类，而HashTable继承自Dictionary类
2. HashMap把HashTable的contains方法去掉了，改成了更为明确的containsValue和containsKey。因为contains方法描述不明确，容易引起误解。
3. HashMap没有考虑同步，不是线程安全的，HashTable使用了synchronized关键字，是线程安全，所以单线程的时候HashMap效率更高
4. HashMap允许Key/Value都为null,HashTable则Key/Value都不允许为null
5. HashMap的初始容量为16，HashTable初始容量为11，两者的填充因子默认都是0.75
6. HashMap扩容时是当前容量翻倍：capactiy*2，HashTable扩容时是容量翻倍+1：capacity * 2+1

## HashMap和HashSet的区别

HashSet底层是基于HashMap实现的。只不过HashSet里面的HashMap所有的value都是同一个Object而已，因此HashSet也是非线程安全的。

1. HashMap实现了Map接口，而HashSet实现了Set接口
2. HashMap存储键值对，HashSet仅仅存储对象
3. HashMap调用put()向map中添加元素，HashSet调用add()向Set中添加元素
4. HashMap使用key计算HashCode，HashSet使用成员对象来计算hashcode值，对于两个对象来说，hashcode可能相同，所以equals()来判断对象的相等性，如果两个对象不同的话，返回false
5. HashMap相对于HashSet较快，因为它使用唯一的键获取对象

## ConcurrentHashMap和HashTable的区别

ConcurrentHashMap结合了HashMap和HashTable的优势。HashMap没有考虑同步，HashTable考虑了同步的问题。但是HashTable在每次同步执行的时候都要锁住整个结构。ConcurrentHashMap锁的方式是稍微细粒度的。

## Set和List的区别

1. Set接口实例存储的是无序的，不重复的数据。List接口实例存储是有序的，可以重复的元素。都可以存储null值，但是set最多只能有一个null值
2. Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变<实现类有HashSet，TreeSet>
3. List和数组类似，可以动态增长，根据实际存储的数据长度，自动增长List的长度。查找元素效率高，插入删除效率低，因为插入和删除会引起其他元素位置改变<实现类有ArrayList，LinkedList，Vector>

## ArrayList和LinkedList的区别

1. ArrayList底层使用的是Object数组，LinkedList底层使用的是双向循环链表数据结构
2. ArrayList采用数组存储，所以插入和删除元素受元素位置的影响，插入末尾还好，如果是中间的话会比较慢，而LinkedList采用链表存储，所以插入和删除元素不受元素位置影响，比较快。
3. LinkedList不支持高效的随机元素访问，而ArrayList实现了RandmoAcess接口，有随机访问功能。快速随机访问就是通过元素的序号快速获取元素对象。所以ArrayList随机访问快，插入慢；LinkedList随机访问慢，插入快。
4. ArrayList的空间花费主要体现在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为是双向链表，所以需要存放直接后继和直接前驱以及数据）。

## ArrayList和Vector的区别

共同点：都实现了List接口，都是有序的集合，我们可以按位置的索引号取出元素，其中数据都是可以重复的，这是和HashSet最不同的，HashSet不可以根据索引号去检索其中的元素，也不允许有重复的元素。

区别：

1. 同步性：Vector是线程安全的，ArrayList是不安全的，如果有多个线程访问集合，最好使用Vector，不需要自己考虑和编写线程安全的代码，如果是单线程，最好使用ArrayList，因为它不考虑线程安全，效率比较高。
2. 数据增长：当存储的元素个数超过了容量时，需要扩容。Vector默认增长为原来的2倍，而ArrayList增长为原来的1.5倍。ArrayList和Vector都可以设置初始空间大小，Vector可以设置增长空间大小。

## HashMap和TreeMap的区别

1. HashMap通过hashcode对其内容进行快速查找，而TreeMap中所有的元素都保持着某种固定的顺序，如果你需要得到一个有序的结果，你就应该使用TreeMap
2. HashMap插入、删除和定位元素会比较好，TreeMap则是有序，如果需要有序遍历key，使用TreeMap会更好。

## 遍历一个List有哪些方式

1. for循环遍历。
2. 迭代器Iterator遍历
3. foreach循环遍历。foreach内部是采用Iterator的方式实现。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作结合数据，例如删除、替换。

# Java 多线程

## 实现多线程的方式

1. 继承Thread类，重写run()
2. 实现Runnable接口,重写run()
3. 实现Callable接口，重写call()
4. 通过线程池

## 线程的run()和start()有什么区别

每个线程都是通过特定Thread对象所对应的方法run()来完成其操作的。

run()方法称为线程体，通过调用Thread类的start()方法来启动一个线程。

start()方法用于启动一个线程，真正实现了多线程运行。

调用start()无需等待run()方法体代码执行完毕，可以继续执行其他的代码，此时线程是出于就绪状态，并没有运行。然后通过此Thread类调用方法run()来完成其运行状态，run()运行结束，此线程终止。然后CPU再调度其他线程。

run()是在本线程里的，只是线程里的一个函数，而不是多线程的。如果直接调用run()，其实就相当于是调用了一个普通函数而已，直接使用run()必须等待run()执行完毕才能执行之后的代码。所以执行路径还是只有一条，根本没有线程的特征，所以在多线程执行时要使用start()而不是run().

## 为什么调用start()时会执行run()，为什么不能直接调用run()

new一个Thread，线程进入了新建状态。调用start()，会启动一个线程，并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。

而直接执行run()，会把run()当成main线程下的普通方法来执行，并不会在某个线程中执行它，这并不是多线程工作。

总结：调用start()才可以启动线程并使线程进入就绪状态，而run()只是Thread的一个普通方法调用，还是需要在主线程里执行。

## Java中线程池是如何实现的

创建一个阻塞队列来容纳任务，在第一次执行任务时创建足够多的线程，并处理任务，之后每个工作线程自动从任务队列中获取线程，直到任务队列中任务为0停止，此时线程处于等待状态，一旦有工作任务加入任务队列中，立刻唤醒工作线程进行处理，实现线程的可复用性。

线程池一般包括四个基本组成部分：

	1. 线程池管理器：用于创建线程池，销毁线程池，添加新任务。
	2. 工作线程：线程池中的线程，可以循环执行任务，在没有任务时处于等待状态
	3. 任务队列：用于存放没有处理的任务，一种缓存机制。
	4. 任务接口：每个任务必须实现的接口，供工作线程调度任务的执行，主要规定了任务的开始和收尾工作和任务的状态。

## 线程的基本状态

根据源码中记录，有6种状态，分别是：

1. New:初始状态，线程被创建，没有调用start()

2. Runnable:运行状态，Java线程把操作系统中的就绪和运行两种状态统一称为“运行中”

3. Blocked:阻塞，线程进入等待状态，线程因为某种原因，放弃了CPU的使用权

   阻塞的几种情况：

   1. 等待阻塞：运行的线程执行了wait()，JVM会把当前线程放入等待队列
   2. 同步阻塞：运行的线程在获取对象的同步锁时，如果该同步锁被其他线程占用了，JVM会把当前线程放入锁池中
   3. 其他阻塞：运行的线程执行sleep(),join()或者发出IO请求时，JVM会把当前线程设置为阻塞状态，当sleep()执行完，join()线程终止，IO处理完毕，线程再次恢复

4. Waiting：等待状态

5. timed_waiting：超时等待状态，超时以后自动返回

6. terminated：终止状态，当前线程执行完毕

   

# JVM

## 垃圾回收机制及算法

### 简述Java垃圾回收机制

在Java中，程序员是不需要手动去释放一个对象的内存的，而是由虚拟机自动执行。在JVM中，有一个垃圾回收线程，它是低优先级的，正常情况下是不会执行，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫描没有被任何引用的对象，并将它们添加到需要回收的集合中，进行回收

### GC是什么？为什么需要GC

GC是垃圾收集的意思，全称为Gabage Collection，内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统的不稳定甚至崩溃，Java提供的GC功能可以自动监测对象是否超过作用域，从而达到自动回收内存的目的，Java语言没有提供释放已分配内存的显示操作方法。

### 垃圾回收的优点和缺点

- 优点：JVM的垃圾回收不需要手动处理无引用的对象
- 缺点：程序员不能实时的对某个对象调用垃圾回收器进行垃圾回收

### 垃圾回收器的原理是什么？有什么办法手动进行垃圾回收？

- 对于GC来说，当程序员创建对象的时候，GC就开始监控这个对象的地址、大小以及使用情况。
- 通常，GC采用有向图的方式记录和管理堆中的所有对象。通过这种方式确定哪些对象是“可达的”，哪些对象是“不可达的”。当GC确定一些对象为“不可达”时，GC就有责任回收这些内存空间。
- 程序员可以手动执行System.gc(),通知GC运行，但是Java语言规范并不保证GC一定会执行。

## JVM垃圾回收算法有哪些

- 标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片
- 复制算法：按照容量划分两个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。
- 标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。
- 分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记-整理算法。

## 什么是双亲委派模型

- 在介绍双亲委派模型之前先说下类的加载器。对于任何一个类，都需要由加载它的类加载器和这个类本身一同确立在JVM中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据制定全限定名称将class文件加载到JVM内存，然后再转化为class对象。
- 类加载器分类：
  - 启动加载器（Boostrap ClassLoader），是虚拟机自身的一部分，用来加载JAVA_HOME/lib/目录中的，或者被 - Xbootclasspath参数所制定的路径中，并且被虚拟机识别的类库
  - 其他加载器：
  - 扩展类加载器（Extension ClassLoader）：负责加载\lib\ext目录或者Java.ext.dirs系统变量hiding的路径中的所有类库
  - 应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器，默认就是用这个加载器。
- 双亲委派模型：如果一个类加载器收到了类加载的请求，它首先不会自己去加载这个类，而是把这个请求委派给父类加载器去完成，每一层的类加载器都是如此，这样所有的加在请求都会被传送到顶层的启动类加载器中，只有当父加载器无法完成加载请求（它的搜索范围中没找到所需要的类）时，子加载器才会尝试去加载类。
- 总结：当一个类收到了类加载请求时，不会自己先去加载这个类，而是将其委派给父类，由父类去加载，如果此时父类不能加载，反馈给子类，再由子类去完成类的加载。
# Spring 
## IOC
IOC 控制反转，也叫依赖注入，他就是不会直接创建对象，只是先把对象声明出来，等到需要使用的时候才将他们创建出来
## 控制反转有什么用
- 管理对象的创建和依赖关系的维护。
- 解耦：由容器来维护具体的对象
- 托管了类的产生过程，应用程序不需要关系类是如何完成代理的
## AOP
面向切面编程，这是一种编程模式。它允许通过自定义的横切点进行模块化，将那些影响多个类的行为封装到可重用的模块中
## 依赖注入的实现方式
- 依赖注入分为接口注入、setter方法注入和构造器注入三种方式，其中接口注入由于灵活性和易用性比较差，从Spring4开始已经被废弃
- __构造器依赖注入__：构造器以来注入通过容器触发一个类的构造器来实现的。
- __setter方法注入__：setter方法注入是容器通过无参构造器实例化bean之后，调用setter方法进行注入
## spring常用的注解以及作用
- @Component：将java类标记为bean
- @Controller：将一个类标记为Spring Web MVC控制器，标记的bean会自动导入到IOC容器中
- @Service：标记Service层
- @Repository：标记dao类，将其导入IOC容器中
- @Required：这个注解表明bean的属性必须在配置的时候设置，通过bean定义的显式属性值或通过自动装配，如果被标记的bean属性未设置，将会跑出BeanInitializationException.
- @Autowired：默认是按照类型装配注入，默认情况下要求对象必须存在
  - 与@Resource的区别
    - @Autowired和@Resource可用于：构造函数、成员变量、Setter方法
    - @Autowired和@Resource的区别在于
      - @Autowired默认是根据类型装配注入的，默认情况下要求依赖对象必须存在，可以设置required属性为false
      - @Resource默认是按照名称来装配注入的，只要找不到名称匹配的bean，才会按照类型来装配注入

- @RequestMappling：用于将特定HTTP请求方法映射到处理相应请求的控制器中的特定方法，

# Spring Cloud
## Spring Cloud 是什么
Spring Cloud 是一个服务治理平台，是若干框架集合，提供了全套的分布式系统解决方案。包含：服务注册与发现、配置中心、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列等等。

# Nginx

## 什么是Nginx

Nginx是一款开源的，高性能HTTP服务器和反向代理服务器，也是一个IMAP、POP3、SMTP代理服务器；Nginx以高性能、稳定性、功能丰富、配置简单和低资源消耗闻名。

## Nginx的特性有哪些

1. 跨平台：可以在Windows、Linux等平台编译运行
2. 配置简单，易上手
3. 非阻塞、高并发链接：数据复制时，磁盘I/O的第一阶段是非阻塞的。官方测试能支持5万并发连接，实际生产中能跑2~3万并发连接数
4. Nginx代理和后端Web服务器不需要长连接
5. Nginx接收用户请求时异步的，先将用户请求全部接收下来，之后一次性发送到后端Web服务器，极大减轻后端Web服务器的压力
6. 发送响应报文时，接收来自后端Web服务器的数据和发给客户端同步进行
7. 网络低依赖性，理论上只要能ping通，就可以实现负载均衡，而且可以有效区分内外网流量
8. 支持内置服务器检测。Nginx能够根据应用服务器处理页面返回的状态码、超时信息能检测服务器是否出现故障，并即使返回错误的请求重新提交到其他节点
9. 内存消耗小，成本低廉，节省带宽，稳定性高等特点


# Redis
## redis的基本数据类型
1. String(字符串)
	1. String是redis最基础的数据类型结构，是二进制安全的，可以存储图片或者序列化的对象，最大存储为512M
	2. 应用场景：共享session、分布式锁、计数器、限流等
2. Hash（哈希）
	1. 在redis中，哈希类型是指value本身又是一个键值对结构
	2. 应用场景：缓存用户信息等
3. List（列表）
	1. 列表类型是用来存储多个有序的字符串，一个列表最多可以存储2^32-1个元素
	2. 应用场景：消息队列，文章列表
4. Set（集合）
	1. set类型也是用来保存多个字符串元素，但是不允许重复元素
	2. 应用场景：用户标签，抽奖等
5. zset（有序集合）
	1. 已排序的字符串集合，同事元素不能重复
	2. 应用场景：排行榜，社交需求（如点赞）等
## 什么是缓存穿透、缓存击穿、缓存雪崩？
### 缓存穿透
#### 常见的缓存使用方式：
读请求来了，先查下缓存，缓存有值直接返回，缓存没找到，就去查数据库，然后把数据库中的值更新到缓存中，然后返回。
#### 缓存穿透：
指查询一个一定不存在的值，由于缓存查不到时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次都要去数据库查询，给数据库带来压力。
#### 产生缓存穿透的情况：
- 业务不合理的设计：比如大多数用户都没有开通会员，但是你每个请求都去缓存中查询某个userid有没有开通会员
- 业务/运维/开发失误的操作：比如缓存和数据库的数据都被误删除了
- 黑客非法请求攻击：比如黑客故意捏造大量非法请求，读取不存在的业务数据
#### 避免缓存穿透：
1. 如果是非法请求，在API入口处，对参数进行校验，过滤非法值
2. 如果查询数据库为空，可以给缓存设置个默认值。但是如果有写请求进来的话，需要进行更新缓存的操作，保证缓存一致性，同时，给缓存设置适当的过期时间。
3. 使用boolean过滤器快速判断数据是否存在。一个请求过来时，先通过布隆过滤器判断值是否存在，存在才继续下面的查询操作
### 缓存击穿

```指某个热点数据过期或者被删除，导致大量请求直接绕过缓存访问数据库，导致数据库压力瞬间升高，甚至崩溃。```

#### 解决方案：
1. 使用互斥锁（Mutex）
	在缓存失效的瞬间，使用互斥锁（Mutex）进行资源控制，只允许一个请求进入数据库查询，其他请求等待。这样可以避免大量请求同时查询数据库，从而导致数据库崩溃
2. 使用分布式锁
	Redis作为分布式缓存，可以使用分布式锁来避免缓存击穿问题。分布式锁可以保证同一时间只有一个线程或进程能够访问某个共享资源，从而避免缓存击穿的问题
3. 使用缓存预热
	在系统启动时，将常用的数据预先加载到缓存中，以避免在运行时缓存失效导致的缓存击穿问题。
4. 使用热点数据永不过期
	对于一些热点数据，可以设置其过期时间为永不过期，从而避免因为缓存失效导致的缓存击穿问题。
5. 使用限流策略
	通过限制并发访问的请求数量。可以使用一些开源的限流框架，如Guava RateLimiter、Spring Cloud Gateway等。
### 缓存雪崩：
	指缓存中大量数据同时过期，而此时查询数据量巨大，请求都需要直接访问数据库，引起数据库的压力过大甚至down机
- 缓存雪崩一般是由于大量数据同时过期导致的，对于这个原因，可以通过均匀设置过期时间解决，让过期时间相对离散一点，不要聚集到一起，比如采用一个较大的固定值+一个较小的随机值，eg:5小时+0~1800秒
- Redis故障宕机也可能引起缓存雪崩，这就需要构造 **Redis高可用集群** 

# MQ

## 为什么使用MQ，使用场景是什么

mq的作用很简单，削峰填谷。以电商交易下单的场景来说，正向交易的过程可能涉及到创建订单、扣减库存、扣减活动预算、扣减积分等等。如果这些操作全部同步处理的话，首先流程太长影响接口性能，其次分布式事务的问题很难处理，这时候像扣减预算和积分这种对实时一致性要求没有那么高的请求，完全可以通过mq异步方式去处理。

MQ优点：
1. 异步处理：相比于传统的串行、并行方式，提高了系统吞吐量
2. 应用解耦：系统间通过消息通信，不用关心其他系统的处理
3. 流量削峰：可以通过消息队列长度控制请求量，可以缓解短时间内的高并发请求
4. 日志处理：解决大量日志传输
5. 消息通讯：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯

## 解耦、异步、削峰是什么

- 解耦：系统A在代码中直接调用系统B和系统C的代码，如果将来再接入新的系统，调用代码还需要修改
- 异步：将消息写入消息队列，非必要的业务逻辑以异步的方式运行，加快响应速度
- 削峰：并发量大的时候，所有请求直接链接数据库，造成数据库连接异常

## 如何保证消息的可靠性

消息不可靠的情况可能是消息丢失、劫持等原因

丢失又分为：生产者丢失消息、消息列表丢失消息、消费者丢失消息

1. 生产者丢失消息：RabbitMQ提供 transaction和Confirm模式来确保生产者不丢消息

   1. transaction机制：发送消息前，开启事务(channel.txSelect()),然后发送消息，如果发送过程中出现什么异常，事务就会回滚(channel.txRollback())，如果发送成功则提交事务(channel.txCommit())。缺点：吞吐量下降
   2. confirm模式用的居多：一旦channel进入confirm模式，所有在该信道上发布的消息都会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者直到消息已经正确到达目的队列了，如果RabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试

2. 消息队列丢数据：消息持久化

   处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。

   这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。

   这样，如果消息在持久化磁盘之前，RabbitMQ阵亡，生产者收不到Ack信号，会自动重发。

   持久化：

   1. 将queue的持久化标识durable设置为true，代码是一个持久的队列
   2. 发消息的时候将deliveryMode=2

3. 消费者丢失消息：消费者丢数据一般是因为采用了自动确认消息模式，改为手动消息

   消费者在收到消息后，处理消息之前，会自动回复RabbitMQ已经收到消息。

   如果这时处理消息失败，就会丢失该消息。所以，修改为处理消息成功之后，手动回复确认消息。

## 如何保证消息不被重复消费？

重复消费原因：正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就会知道该消息被消费了，就会将该消息从消息队列中删除。但是，因为网络传输等故障，确认消息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息，再次将消息分发给其他消费者。

解决思路：保证消息的唯一性，就算是多次传输，不需要让消息的多次消费带来影响，保证消息的幂等性。

​	比如：在写入消息队列的数据做唯一标识，消费消息时，根据唯一标识判断是否消费过。

## 如何保证消息的顺序性

- 拆分多个消息队列，每个消息队列一个消费者
- 或者就一个消息队列，但是对应一个消费者，然后这个消费者内部用内存队列做排队，然后分发给底层不同的worker来处理

# 源码解析
## HashMap
### 概述
HashMap 1.7采用数组+链表实现，使用链表处理冲突，同一hash值的节点都存储在一个链表里。但是当位于一个捅中的元素较多，即hash值相等的元素较多时，通过key值一次查找的效率较低。而JDK1.8中，HashMap采用数组+链表+红黑树实现，当链表长度超过阈值（8）时，将链表转换为红黑树，这样大大减少了查找时间。

